# Transition vers l'Infrastructure as Code (IaC)

La transition vers l'Infrastructure as Code (IaC) repr√©sente une √©volution incontournable dans la gestion des infrastructures informatiques.  
Avant cette approche, la configuration des ressources √©tait souvent manuelle, propice aux erreurs humaines, aux retards et √† l'absence de standardisation.

Gr√¢ce √† l'IaC, l'infrastructure est repr√©sent√©e **sous forme de code** :  
cela permet d'automatiser les d√©ploiements, d'assurer une reproductibilit√© parfaite et de faciliter la maintenance.

L'un des grands avantages de l'IaC est la **possibilit√© de versionner** toute l'infrastructure :  
cela favorise la collaboration entre √©quipes et rend chaque modification **tra√ßable** dans le temps.  
Des outils de versionnement comme **Git** deviennent alors indispensables pour garantir la coh√©rence, la transparence et la fiabilit√© de l'environnement.

---

# Le Dockerfile

Un **Dockerfile** est un simple fichier texte d√©crivant, ligne par ligne, comment construire l‚Äôimage Docker d‚Äôune application.  
Il sp√©cifie :
- l'image de base utilis√©e,
- les d√©pendances √† installer,
- les fichiers √† copier,
- la configuration de d√©marrage, etc.

Lorsque vous ex√©cutez `docker build`, vous construisez une **image Docker** comprenant tous les utilitaires et les param√®tres n√©cessaires √† votre application.  
Pour d√©marrer une machine bas√©e sur cette image, vous utiliserez ensuite `docker run`.

| Instruction | R√¥le | Exemple |
|:------------|:-----|:--------|
| **FROM** | D√©finit l‚Äôimage de base (distribution Linux, image applicative, etc.). Premi√®re ligne obligatoire. | `FROM python:3.12-slim` |
| **RUN** | Ex√©cute une commande durant la construction (installer des paquets, compiler du code, etc.). Chaque `RUN` cr√©e une nouvelle couche d'image. | `RUN apt-get update && apt-get install -y git` |
| **ENTRYPOINT** | D√©finit la commande par d√©faut ex√©cut√©e lors du d√©marrage du conteneur. Permet de rendre le conteneur autonome. | `ENTRYPOINT ["python", "app.py"]` |

---

# Le fichier docker-compose

Un **docker-compose.yml** est un manifeste IaC d√©crivant en **YAML** l‚Äôensemble des services n√©cessaires √† une application conteneuris√©e.

Il offre :
- une vue d‚Äôensemble claire de l‚Äôinfrastructure : images utilis√©es, r√©seaux, volumes, variables d‚Äôenvironnement, d√©pendances entre services...
- une orchestration **automatis√©e** de vos conteneurs.

C'est un outil crucial pour composer et d√©ployer des applications complexes **√† la demande**, en optimisant les co√ªts tout en respectant fid√®lement toutes les sp√©cifications techniques.



```yaml
name: string
services:
    machine1:
        ...
    ...
volumes:

networks:
```
---

# La CI : Continuous Integration (Int√©gration Continue)

La **CI** automatise la construction, le test et le d√©ploiement de votre application dans des environnements **propres** et **ext√©rieurs** √† votre machine locale.

Sur GitHub, cette logique repose sur des **runners** (machines d√©di√©es) qui ex√©cutent vos pipelines d√©crits dans des fichiers pr√©sents sous `.github/workflows/`.

Gr√¢ce √† la CI :
- votre code devient **portable**,
- chaque mise √† jour d√©clenche automatiquement des **tests**,
- vous √™tes imm√©diatement alert√© (g√©n√©ralement par un indicateur vert ou rouge) sur l'√©tat de sant√© de votre infrastructure.

Cela vous garantit que votre application fonctionne non seulement sur votre machine, mais aussi sur n'importe quel environnement cible.

---

# Bonnes pratiques

- Par d√©faut, chaque conteneur est **isol√©** du syst√®me h√¥te, fonctionnant comme une machine virtuelle l√©g√®re.
- Pouvoir **scripter**, **versionner**, et **partager** vos environnements est un **atout majeur** :  
il r√©duit les erreurs, acc√©l√®re les d√©ploiements et facilite la collaboration entre √©quipes.

En combinant Docker, IaC et CI, vous construisez des infrastructures **solides**, **scalables** et **fiables**, pr√™tes pour la production moderne.

---

# Introduction √† Kubernetes

Lorsque les applications deviennent plus complexes (multi-conteneurs, besoin d'auto-scaling, haute disponibilit√©, etc.), **Kubernetes** s'impose naturellement comme une suite logique √† **docker-compose**.

**Kubernetes** est un orchestrateur de conteneurs qui :
- D√©ploie,
- G√®re,
- Met √† l‚Äô√©chelle,
- Et supervise vos applications conteneuris√©es.

En simplifi√© :
- **Docker-compose** d√©crit des **services** dans un fichier YAML.
- **Kubernetes** d√©crit des **d√©ploiements** et des **services**... √©galement en YAML, mais avec plus de puissance et de contr√¥le.

| Concept docker-compose | Concept Kubernetes √©quivalent |
|:------------------------|:-------------------------------|
| `services:`             | `Deployment` + `Service`        |
| `volumes:`              | `PersistentVolumeClaim (PVC)`   |
| `networks:`             | `ClusterIP / NodePort / Ingress` |

Ainsi, migrer de **docker-compose** √† **Kubernetes** reste naturel, m√™me si Kubernetes apporte plus de fonctionnalit√©s avanc√©es.

---

# Minikube : Kubernetes local

Pour tester Kubernetes localement sans infrastructure lourde, **Minikube** est la solution id√©ale.

Minikube :
- Lance un **cluster Kubernetes complet** sur votre machine, dans une VM ou un conteneur Docker.
- Permet de d√©velopper et tester des applications Kubernetes **localement**, comme si vous √©tiez sur un cloud public.

**Installation rapide de Minikube :**
```bash
# Sur Linux/Mac
curl -LO https://storage.googleapis.com/minikube/releases/latest/minikube-linux-amd64
sudo install minikube-linux-amd64 /usr/local/bin/minikube

# D√©marrer un cluster
minikube start
```

---

# D√©ployer et exposer un service sur Kubernetes

Le minimum pour d√©ployer une application sur Kubernetes est :

1. **Un fichier Deployment YAML** pour d√©crire comment lancer vos conteneurs :
```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: my-app
spec:
  replicas: 1
  selector:
    matchLabels:
      app: my-app
  template:
    metadata:
      labels:
        app: my-app
    spec:
      containers:
      - name: my-container
        image: myimage:latest
        ports:
        - containerPort: 80
```

2. **Un fichier Service YAML** pour rendre votre application accessible :
```yaml
apiVersion: v1
kind: Service
metadata:
  name: my-app-service
spec:
  type: NodePort
  selector:
    app: my-app
  ports:
  - port: 80
    targetPort: 80
    nodePort: 30080
```

Une fois appliqu√© (`kubectl apply -f .`), vous pourrez acc√©der √† votre service via :
```bash
minikube service my-app-service
```
Cela ouvre automatiquement l‚ÄôURL de votre application dans le navigateur.

---

Parfait, je vois exactement ce que tu veux :  

‚ûî **Repartir vraiment de z√©ro**, **sans fichier inventory.ini**,  
‚ûî **Expliquer Ansible** √† quelqu'un qui **n'y conna√Æt rien du tout**.  
‚ûî **Contexte local** : tout fonctionne **directement sur localhost**.

Donc on doit **rester ultra simple**, **pragmatique**, **clair**.

---

# üìñ Ansible 

**Ansible** est un **outil d'automatisation**.

Il permet de **faire des actions automatiques** sur un ordinateur ou sur plusieurs serveurs, sans devoir r√©p√©ter les m√™mes commandes √† la main.

Exemples d'actions qu'Ansible peut faire :
- Installer un programme (`apt install nginx`),
- Copier un fichier (`cp monfichier /etc/monfichier`),
- Red√©marrer un service (`systemctl restart nginx`),
- Modifier une configuration (`changer une ligne dans un fichier`).

**Avec Ansible**, on **d√©crit** ce qu'on veut dans un fichier texte, et Ansible **ex√©cute** tout, dans l'ordre.

---

# Comment √ßa marche ?

Ansible lit **un fichier de sc√©nario** (qu'on appelle un **playbook**) √©crit en **YAML**.

Un playbook dit :
- **Sur quelle machine** faire les actions,
- **Quelles actions** faire,
- **Dans quel ordre**.

Tu √©cris ton sc√©nario une seule fois, et tu peux le rejouer **autant de fois que tu veux** sans erreurs.

---

# Utiliser Ansible en local (sur sa propre machine)

Quand on veut utiliser Ansible **sur son propre ordinateur**, on :
- indique dans le playbook que la cible est `localhost`,
- pr√©cise qu'on utilise une **connexion locale** (pas besoin de r√©seau, pas de SSH).

Ainsi, Ansible **travaille directement** sur ta machine comme si tu tapais les commandes toi-m√™me.

---

# Exemple ultra simple d'un fichier `playbook.yml`

Voici un fichier qui **installe "htop"** sur ta machine :

```yaml
- name: Installer un programme sur localhost
  hosts: localhost
  connection: local
  gather_facts: false
  tasks:
    - name: Installer htop
      become: yes
      apt:
        name: htop
        state: present
```

**Que veut dire ce fichier ?**
- "Je travaille sur `localhost` (ma propre machine)."
- "Je n'ai pas besoin d'aller chercher des informations syst√®me compliqu√©es (`gather_facts: false`)."
- "Je vais ex√©cuter une action : installer `htop`."
- "Je fais cela avec les droits administrateur (`become: yes`)."

---

# Faire un ls sur une machine linux

Voici un fichier qui **installe "htop"** sur ta machine :

```yaml
- name: Executer des commandes shell sur ansible
  hosts: localhost
  connection: local
  gather_facts: false
  tasks:
    - name: Executer des commandes shell
      shell: |
        ls
        # A la suite toutes mes autres commandes
```

**Que veut dire ce fichier ?**
- "Je travaille sur `localhost` (ma propre machine)."
- "Je n'ai pas besoin d'aller chercher des informations syst√®me compliqu√©es (`gather_facts: false`)."
- "Je vais ex√©cuter une action : installer `htop`."
- "Je fais cela avec les droits administrateur (`become: yes`)."

---

# Comment l'utiliser ?

1. Installer Ansible :

```bash
sudo apt update
sudo apt install ansible
```

2. Modifi√© le fichier `cd.yml` afin que nous puissions observer le workflow attack/defense.

3. Lancer Ansible :

```bash
ansible-playbook cd.yml
```

**Et c'est tout.**

Ton ordinateur va :
- Lire le fichier,
- Ex√©cuter chaque action,
- Et installer automatiquement ce que tu as demand√©.

---
